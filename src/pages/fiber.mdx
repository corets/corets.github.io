---
name: Fiber
route: /fiber
repository: fiber
---

# Fiber

Statically typed client for remote, RPC style communication. Consume your backend API through a statically typed facade, without any code generation, without writing any custom API calls or duplicating your backend types on the client side. Fibers work in any TypeScript setup and are fully implementation agnostic.

- Full static typing from tail to toe
- Implementation agnostic
- Works for client to server or server to server communication
- Build an SDK for your backend in minutes
- No code generation

```bash
yarn add @corets/fiber
```

## Quick start

First you need to create a fiber and register all the methods that you want to expose accordingly:

```ts
import { createFiber } from "@corets/fiber"

const makeResponse = (status: number, result: any) => {
  return { status, result }
}

const pingPong = (input: string) => {
  return makeResponse(200, input === "ping" ? "pong" : "ping")
}

export const fiber = createFiber({ pingPong })
export type MyFiber = typeof fiber
```

Next you need to setup your server, we'll be using express in this example:

```tsx
import express from "express"
import { fiber } from "./fiber"

const app = express()

app.post("/fiber/:method", async (req, res) => {
  try {
    const method = req.params?.method
    const args = Object.values(req?.body)
    const response = await fiber.call(method, ...args)

    res.status(response.status).json(response.result)
  } catch (err) {
    console.error(err)
    res.status(500).send()
  }
})

app.listen(1337)
```

Next you create a consumer for your fiber, on the client side, we'll use axios in this example:

```ts
import { createFiberClient } from "@corets/fiber"
import axios from "axios"
import type { MyFiber } from "./fiber"

export const client = createFiberClient<MyFiber>(async (method, ...args) => {
  const res = await axios.post(`http://localhost:1337/fiber/${method}`, args)

  return res.data
})
```

Now you have a statically typed, RPC style client, that you can consume immediately on the client side (web, node, mobile):

```ts
import { client } from "./client"

// returns pong
const answer = await client.pingPong("ping")
```

## `createFiber`

Create a new fiber instance on the producer side:

```ts
import { createFiber } from "@corets/fiber"

const myMethod = () => "hallo"

const fiber = createFiber({ myMethod })
```

**Note:** Returns an instance of [SimpleFiber](#simplefiber).

## `createFiberClient`

Create a statically typed fiber client:

```ts
import { createFiberClient } from "@corets/fiber"
import type { fiber } from "./fiber"

const client = createFiberClient<typeof fiber>((method, ...args) => {
  // proxy request to producer
})
```

**Note:** Returns an instance of [SimpleFiberClient](#simplefiberclient).

## `SimpleFiber`

Statically typed facade that is used to bootstrap a fiber instance on the producer side.

## `SimpleFiber.call`

Call a registered fiber method on the producer side:

```ts
import { createFiber } from "@corets/fiber"

const fiber = createFiber({
  greet (name: string) {
    return `Hallo ${name}!`
  }
})

// method names and parameters are fully statically typed
const greeting = await fiber.call("greet", "John")
```

## `SimpleFiberClient`

Statically typed client for a fiber, used on the consumer side.

## `SimpleFiberClient.call`

```ts
import { createFiberClient } from "@corets/fiber"
import type { MyFiber } from "./fiber"

const client = createFiberClient<MyFiber>((method, ...args) => {
  // bridge implementation
})

// method names and parameters are fully statically typed
const response = await client.call("greeting", "John")
// or
const response = await client.greeting("John")
```

